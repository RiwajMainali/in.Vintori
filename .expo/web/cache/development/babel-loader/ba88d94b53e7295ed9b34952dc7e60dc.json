{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { defineHidden, is, createInterpolator, eachProp, hasFluidValue, getFluidValue, each, isAnimatedString, useForceUpdate, useIsomorphicLayoutEffect, addFluidObserver, removeFluidObserver, raf, useOnce } from '@react-spring/shared';\nimport * as React from 'react';\nimport { forwardRef, useRef, useCallback, useEffect } from 'react';\nvar $node = Symbol.for('Animated:node');\nvar isAnimated = function isAnimated(value) {\n  return !!value && value[$node] === value;\n};\nvar getAnimated = function getAnimated(owner) {\n  return owner && owner[$node];\n};\nvar setAnimated = function setAnimated(owner, node) {\n  return defineHidden(owner, $node, node);\n};\nvar getPayload = function getPayload(owner) {\n  return owner && owner[$node] && owner[$node].getPayload();\n};\nvar Animated = function () {\n  function Animated() {\n    _classCallCheck(this, Animated);\n    this.payload = void 0;\n    setAnimated(this, this);\n  }\n  _createClass(Animated, [{\n    key: \"getPayload\",\n    value: function getPayload() {\n      return this.payload || [];\n    }\n  }]);\n  return Animated;\n}();\nvar AnimatedValue = function (_Animated) {\n  _inherits(AnimatedValue, _Animated);\n  var _super = _createSuper(AnimatedValue);\n  function AnimatedValue(_value) {\n    var _this;\n    _classCallCheck(this, AnimatedValue);\n    _this = _super.call(this);\n    _this.done = true;\n    _this.elapsedTime = void 0;\n    _this.lastPosition = void 0;\n    _this.lastVelocity = void 0;\n    _this.v0 = void 0;\n    _this.durationProgress = 0;\n    _this._value = _value;\n    if (is.num(_this._value)) {\n      _this.lastPosition = _this._value;\n    }\n    return _this;\n  }\n  _createClass(AnimatedValue, [{\n    key: \"getPayload\",\n    value: function getPayload() {\n      return [this];\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this._value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value, step) {\n      if (is.num(value)) {\n        this.lastPosition = value;\n        if (step) {\n          value = Math.round(value / step) * step;\n          if (this.done) {\n            this.lastPosition = value;\n          }\n        }\n      }\n      if (this._value === value) {\n        return false;\n      }\n      this._value = value;\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var done = this.done;\n      this.done = false;\n      if (is.num(this._value)) {\n        this.elapsedTime = 0;\n        this.durationProgress = 0;\n        this.lastPosition = this._value;\n        if (done) this.lastVelocity = null;\n        this.v0 = null;\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      return new AnimatedValue(value);\n    }\n  }]);\n  return AnimatedValue;\n}(Animated);\nvar AnimatedString = function (_AnimatedValue) {\n  _inherits(AnimatedString, _AnimatedValue);\n  var _super2 = _createSuper(AnimatedString);\n  function AnimatedString(value) {\n    var _this2;\n    _classCallCheck(this, AnimatedString);\n    _this2 = _super2.call(this, 0);\n    _this2._string = null;\n    _this2._toString = void 0;\n    _this2._toString = createInterpolator({\n      output: [value, value]\n    });\n    return _this2;\n  }\n  _createClass(AnimatedString, [{\n    key: \"getValue\",\n    value: function getValue() {\n      var value = this._string;\n      return value == null ? this._string = this._toString(this._value) : value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      if (is.str(value)) {\n        if (value == this._string) {\n          return false;\n        }\n        this._string = value;\n        this._value = 1;\n      } else if (_get(_getPrototypeOf(AnimatedString.prototype), \"setValue\", this).call(this, value)) {\n        this._string = null;\n      } else {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(goal) {\n      if (goal) {\n        this._toString = createInterpolator({\n          output: [this.getValue(), goal]\n        });\n      }\n      this._value = 0;\n      _get(_getPrototypeOf(AnimatedString.prototype), \"reset\", this).call(this);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      return new AnimatedString(value);\n    }\n  }]);\n  return AnimatedString;\n}(AnimatedValue);\nvar TreeContext = {\n  dependencies: null\n};\nvar AnimatedObject = function (_Animated2) {\n  _inherits(AnimatedObject, _Animated2);\n  var _super3 = _createSuper(AnimatedObject);\n  function AnimatedObject(source) {\n    var _this3;\n    _classCallCheck(this, AnimatedObject);\n    _this3 = _super3.call(this);\n    _this3.source = source;\n    _this3.setValue(source);\n    return _this3;\n  }\n  _createClass(AnimatedObject, [{\n    key: \"getValue\",\n    value: function getValue(animated) {\n      var values = {};\n      eachProp(this.source, function (source, key) {\n        if (isAnimated(source)) {\n          values[key] = source.getValue(animated);\n        } else if (hasFluidValue(source)) {\n          values[key] = getFluidValue(source);\n        } else if (!animated) {\n          values[key] = source;\n        }\n      });\n      return values;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(source) {\n      this.source = source;\n      this.payload = this._makePayload(source);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.payload) {\n        each(this.payload, function (node) {\n          return node.reset();\n        });\n      }\n    }\n  }, {\n    key: \"_makePayload\",\n    value: function _makePayload(source) {\n      if (source) {\n        var payload = new Set();\n        eachProp(source, this._addToPayload, payload);\n        return Array.from(payload);\n      }\n    }\n  }, {\n    key: \"_addToPayload\",\n    value: function _addToPayload(source) {\n      var _this4 = this;\n      if (TreeContext.dependencies && hasFluidValue(source)) {\n        TreeContext.dependencies.add(source);\n      }\n      var payload = getPayload(source);\n      if (payload) {\n        each(payload, function (node) {\n          return _this4.add(node);\n        });\n      }\n    }\n  }]);\n  return AnimatedObject;\n}(Animated);\nvar AnimatedArray = function (_AnimatedObject) {\n  _inherits(AnimatedArray, _AnimatedObject);\n  var _super4 = _createSuper(AnimatedArray);\n  function AnimatedArray(source) {\n    _classCallCheck(this, AnimatedArray);\n    return _super4.call(this, source);\n  }\n  _createClass(AnimatedArray, [{\n    key: \"getValue\",\n    value: function getValue() {\n      return this.source.map(function (node) {\n        return node.getValue();\n      });\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(source) {\n      var payload = this.getPayload();\n      if (source.length == payload.length) {\n        return payload.map(function (node, i) {\n          return node.setValue(source[i]);\n        }).some(Boolean);\n      }\n      _get(_getPrototypeOf(AnimatedArray.prototype), \"setValue\", this).call(this, source.map(makeAnimated));\n      return true;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(source) {\n      return new AnimatedArray(source);\n    }\n  }]);\n  return AnimatedArray;\n}(AnimatedObject);\nfunction makeAnimated(value) {\n  var nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\nfunction getAnimatedType(value) {\n  var parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar withAnimated = function withAnimated(Component, host) {\n  var hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef(function (givenProps, givenRef) {\n    var instanceRef = useRef(null);\n    var ref = hasInstance && useCallback(function (value) {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    var _getAnimatedState = getAnimatedState(givenProps, host),\n      _getAnimatedState2 = _slicedToArray(_getAnimatedState, 2),\n      props = _getAnimatedState2[0],\n      deps = _getAnimatedState2[1];\n    var forceUpdate = useForceUpdate();\n    var callback = function callback() {\n      var instance = instanceRef.current;\n      if (hasInstance && !instance) {\n        return;\n      }\n      var didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n    var observer = new PropsObserver(callback, deps);\n    var observerRef = useRef();\n    useIsomorphicLayoutEffect(function () {\n      observerRef.current = observer;\n      each(deps, function (dep) {\n        return addFluidObserver(dep, observer);\n      });\n      return function () {\n        if (observerRef.current) {\n          each(observerRef.current.deps, function (dep) {\n            return removeFluidObserver(dep, observerRef.current);\n          });\n          raf.cancel(observerRef.current.update);\n        }\n      };\n    });\n    useEffect(callback, []);\n    useOnce(function () {\n      return function () {\n        var observer = observerRef.current;\n        each(observer.deps, function (dep) {\n          return removeFluidObserver(dep, observer);\n        });\n      };\n    });\n    var usedProps = host.getComponentProps(props.getValue());\n    return React.createElement(Component, _extends({}, usedProps, {\n      ref: ref\n    }));\n  });\n};\nvar PropsObserver = function () {\n  function PropsObserver(update, deps) {\n    _classCallCheck(this, PropsObserver);\n    this.update = update;\n    this.deps = deps;\n  }\n  _createClass(PropsObserver, [{\n    key: \"eventObserved\",\n    value: function eventObserved(event) {\n      if (event.type == 'change') {\n        raf.write(this.update);\n      }\n    }\n  }]);\n  return PropsObserver;\n}();\nfunction getAnimatedState(props, host) {\n  var dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = _extends({}, props, {\n    style: host.createAnimatedStyle(props.style)\n  });\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n  return value;\n}\nvar cacheKey = Symbol.for('AnimatedComponent');\nvar createHost = function createHost(components) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$applyAnimatedVal = _ref.applyAnimatedValues,\n    _applyAnimatedValues = _ref$applyAnimatedVal === void 0 ? function () {\n      return false;\n    } : _ref$applyAnimatedVal,\n    _ref$createAnimatedSt = _ref.createAnimatedStyle,\n    _createAnimatedStyle = _ref$createAnimatedSt === void 0 ? function (style) {\n      return new AnimatedObject(style);\n    } : _ref$createAnimatedSt,\n    _ref$getComponentProp = _ref.getComponentProps,\n    _getComponentProps = _ref$getComponentProp === void 0 ? function (props) {\n      return props;\n    } : _ref$getComponentProp;\n  var hostConfig = {\n    applyAnimatedValues: _applyAnimatedValues,\n    createAnimatedStyle: _createAnimatedStyle,\n    getComponentProps: _getComponentProps\n  };\n  var animated = function animated(Component) {\n    var displayName = getDisplayName(Component) || 'Anonymous';\n    if (is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n    Component.displayName = \"Animated(\" + displayName + \")\";\n    return Component;\n  };\n  eachProp(components, function (Component, key) {\n    if (is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n    animated[key] = animated(Component);\n  });\n  return {\n    animated: animated\n  };\n};\nvar getDisplayName = function getDisplayName(arg) {\n  return is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n};\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };","map":{"version":3,"names":["defineHidden","is","createInterpolator","eachProp","hasFluidValue","getFluidValue","each","isAnimatedString","useForceUpdate","useIsomorphicLayoutEffect","addFluidObserver","removeFluidObserver","raf","useOnce","React","forwardRef","useRef","useCallback","useEffect","$node","Symbol","for","isAnimated","value","getAnimated","owner","setAnimated","node","getPayload","Animated","payload","AnimatedValue","_value","done","elapsedTime","lastPosition","lastVelocity","v0","durationProgress","num","step","Math","round","AnimatedString","_string","_toString","output","str","goal","getValue","TreeContext","dependencies","AnimatedObject","source","setValue","animated","values","key","_makePayload","reset","Set","_addToPayload","Array","from","add","AnimatedArray","map","length","i","some","Boolean","makeAnimated","nodeType","create","getAnimatedType","parentNode","constructor","arr","_extends","Object","assign","bind","target","arguments","prototype","hasOwnProperty","call","apply","withAnimated","Component","host","hasInstance","fun","isReactComponent","givenProps","givenRef","instanceRef","ref","current","updateRef","getAnimatedState","props","deps","forceUpdate","callback","instance","didUpdate","applyAnimatedValues","observer","PropsObserver","observerRef","dep","cancel","update","usedProps","getComponentProps","createElement","event","type","write","style","createAnimatedStyle","cacheKey","createHost","components","_applyAnimatedValues","_createAnimatedStyle","_getComponentProps","hostConfig","displayName","getDisplayName","arg","name"],"sources":["H:/inVintori/in.Vintori/node_modules/@react-spring/animated/dist/react-spring-animated.esm.js"],"sourcesContent":["import { defineHidden, is, createInterpolator, eachProp, hasFluidValue, getFluidValue, each, isAnimatedString, useForceUpdate, useIsomorphicLayoutEffect, addFluidObserver, removeFluidObserver, raf, useOnce } from '@react-spring/shared';\nimport * as React from 'react';\nimport { forwardRef, useRef, useCallback, useEffect } from 'react';\n\nconst $node = Symbol.for('Animated:node');\nconst isAnimated = value => !!value && value[$node] === value;\nconst getAnimated = owner => owner && owner[$node];\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\nclass Animated {\n  constructor() {\n    this.payload = void 0;\n    setAnimated(this, this);\n  }\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this.done = true;\n    this.elapsedTime = void 0;\n    this.lastPosition = void 0;\n    this.lastVelocity = void 0;\n    this.v0 = void 0;\n    this.durationProgress = 0;\n    this._value = _value;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.durationProgress = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = void 0;\n    this._toString = createInterpolator({\n      output: [value, value]\n    });\n  }\n\n  static create(value) {\n    return new AnimatedString(value);\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\nconst TreeContext = {\n  dependencies: null\n};\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    const values = {};\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n\n  _addToPayload(source) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(source) {\n    const payload = this.getPayload();\n\n    if (source.length == payload.length) {\n      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);\n    }\n\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n\n}\n\nfunction makeAnimated(value) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nconst withAnimated = (Component, host) => {\n  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef((givenProps, givenRef) => {\n    const instanceRef = useRef(null);\n    const ref = hasInstance && useCallback(value => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = useForceUpdate();\n\n    const callback = () => {\n      const instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return;\n      }\n\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = useRef();\n    useIsomorphicLayoutEffect(() => {\n      observerRef.current = observer;\n      each(deps, dep => addFluidObserver(dep, observer));\n      return () => {\n        if (observerRef.current) {\n          each(observerRef.current.deps, dep => removeFluidObserver(dep, observerRef.current));\n          raf.cancel(observerRef.current.update);\n        }\n      };\n    });\n    useEffect(callback, []);\n    useOnce(() => () => {\n      const observer = observerRef.current;\n      each(observer.deps, dep => removeFluidObserver(dep, observer));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return React.createElement(Component, _extends({}, usedProps, {\n      ref: ref\n    }));\n  });\n};\n\nclass PropsObserver {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      raf.write(this.update);\n    }\n  }\n\n}\n\nfunction getAnimatedState(props, host) {\n  const dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = _extends({}, props, {\n    style: host.createAnimatedStyle(props.style)\n  });\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\nconst createHost = (components, {\n  applyAnimatedValues: _applyAnimatedValues = () => false,\n  createAnimatedStyle: _createAnimatedStyle = style => new AnimatedObject(style),\n  getComponentProps: _getComponentProps = props => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues: _applyAnimatedValues,\n    createAnimatedStyle: _createAnimatedStyle,\n    getComponentProps: _getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || 'Anonymous';\n\n    if (is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}